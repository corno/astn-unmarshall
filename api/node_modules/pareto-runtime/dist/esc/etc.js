"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cc = exports.au = exports.getElement = exports.escapeString = exports.stringIsNaN = exports.parseInt = exports.encodeURI = exports.forEachEntry = exports.Objectkeys = exports.StringFromCharCode = exports.JSONparse = exports.JSONstringify = exports.trimRight = exports.log = exports.logWarning = exports.logError = void 0;
var reexport_globals_1 = require("./reexport_globals");
function logError(message) {
    console.error(message);
}
exports.logError = logError;
function logWarning(message) {
    console.warn(message);
}
exports.logWarning = logWarning;
function log(message) {
    console.log(message);
}
exports.log = log;
function trimRight(str) {
    return str.trimRight();
}
exports.trimRight = trimRight;
function JSONstringify(o) {
    return JSON.stringify(o, undefined, "\t");
}
exports.JSONstringify = JSONstringify;
function JSONparse(str) {
    return JSON.parse(str);
}
exports.JSONparse = JSONparse;
function StringFromCharCode(charCode) {
    return String.fromCharCode(charCode);
}
exports.StringFromCharCode = StringFromCharCode;
function Objectkeys(o) {
    return Object.keys(o);
}
exports.Objectkeys = Objectkeys;
function forEachEntry(dictionary, callback) {
    Objectkeys(dictionary).forEach(function (key) {
        callback(dictionary[key], key);
    });
}
exports.forEachEntry = forEachEntry;
function encodeURI(uri) {
    return (0, reexport_globals_1._encodeURI)(uri);
}
exports.encodeURI = encodeURI;
function parseInt(str, radix) {
    return (0, reexport_globals_1._parseInt)(str, radix);
}
exports.parseInt = parseInt;
function stringIsNaN(str) {
    return isNaN(new Number(str).valueOf());
}
exports.stringIsNaN = stringIsNaN;
function escapeString($) {
    var out = "";
    for (var i = 0; i !== $.str.length; i += 1) {
        var curChar = $.str.charCodeAt(i);
        //solidus characters ( / ) are not escaped!
        //backspace and form feed are escaped using the hexadecimal notation, not the shorthands \b and \f
        if ($.str[i] === "\\") {
            out += "\\\\";
        }
        else if ($.str[i] === $.wrapperToEscape) {
            out += "\\" + $.wrapperToEscape;
        }
        else if ($.str[i] === "\n") {
            out += $.escapeTabsAndNewLines ? "\\n" : $.str[i];
        }
        else if ($.str[i] === "\r") {
            out += $.escapeTabsAndNewLines ? "\\r" : $.str[i];
        }
        else if ($.str[i] === "\t") {
            out += $.escapeTabsAndNewLines ? "\\t" : $.str[i];
        }
        else if ($.str.charCodeAt(i) < 32) {
            //control character (some of them have already been escaped above)
            out += "\\u" + curChar.toString(16).toUpperCase().padStart(4, "0");
        }
        else {
            out += $.str[i];
        }
    }
    return out;
}
exports.escapeString = escapeString;
function getElement(array, index) {
    return array[index];
}
exports.getElement = getElement;
/**
 * au means 'assert unreachable'. Used in the 'default' clause of while statements to ensure that
 * all possible cases have been handled
 * @param _x
 */
function au(_x) {
    throw new Error("unreachable");
}
exports.au = au;
/**
 * cc means 'change context'. It creates a new scope in which a variable name can be used again
 * (usually '$', a variable name that indicates the current context in pareto)
 *
 * @param input
 * @param callback
 * @returns
 */
function cc(input, callback) {
    return callback(input);
}
exports.cc = cc;
